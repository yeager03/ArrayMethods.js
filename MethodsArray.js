// Один из аспектов обработки массивов, к сожалению, невразумительный, относится к различию между методами,
// изменяющими сам массив "по месту'', и методами, возвращающими новый массив. Никакого соглашения по этому поводу нет,
// и это только один из нюансов, которые вам придется запомнить (например, метод push изменяет сам массив,
// а concat - возвращает новый массив).

// stack(LIFO) - push, pop
// queue(FIFO) - push, shift

/* №1 Добавление отдельных элементов в начало или конец и их удаление */
//-----------------------------------------------------Push, Pop--------------------------------------------------------
// push - добавляет в конец массива, возвращает новую длину массива
// pop - удаление последнего элемента массива, возвращает нам удаленный элемент

// push , pop - это действие со стеком(stack), в котором первый извлекается элемент, добавленный последним.

let my_array = [99, 88, 77, 66];
my_array.push(55, 44, 33); // возвращает новую длинну
console.log(my_array); // [99, 88, 77, 66, 55, 44, 33]
console.log(my_array.push(22)); // вернул нам длину

my_array.pop(); // ничего не передаем в качестве аргумента, удаляем 22
console.log(my_array); // [99, 88, 77, 66, 55, 44, 33]
console.log(my_array.pop()); // удаляем и выводим, какой же элемент был удалён, в данном случае 33
console.log(my_array); // [99, 88, 77, 66, 55, 44]

//----------------------------------------------------Shift , unshift---------------------------------------------------
// unshift - добавляет элемент в начало массива, возвращает новую длину массива
// shift - удаляет первый элемент массива, возвращает нам удаленный элемент

// shift и unshift обрабатывают массив как очередь(queue), в которой первым извлекается элемент,
// добавленный в очередь первым.
my_array = [36, 4, 55, 6];
let deleted_first_el = my_array.shift(); // удаляем первый элемент из массива, и записываем его в переменную

console.log(deleted_first_el); // 36
console.log(my_array); // [4, 55, 6]

my_array.unshift(22);
console.log(my_array); // [22, 4, 55, 6]


/* №2 Добавление нескольких элементов в конец */
//--------------------------------------------------------Concat--------------------------------------------------------
// Метод concat добавляет в массив несколько элементов и возвращает его копию.
my_array = [1, 2, 3];
let new_concat_array = my_array.concat(4, 5, 6);

console.log(new_concat_array); // [1, 2, 3, 4, 5, 6]
console.log(my_array); // [1, 2, 3], при этом my_array неизменен

new_concat_array = new_concat_array.concat([7, 8, 9], [10]);

console.log(new_concat_array); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
console.log(my_array); // [1, 2, 3], при этом my_array неизменен

let second_array = [11, 22, 33];
let two_concat_array = my_array.concat(second_array);
console.log(two_concat_array); // [1, 2, 3, 11, 22, 33]

/* №3 Получение подмассива */
//-----------------------------------------------Slice-----------------------------------------------
// Eсли вы хотите получить подмассив из массива, используйте метод slice, которому можно передать два аргумента.
// Первый аргумент - индекс начала подмассива, а второй - индекс его конца (не включая указанный элемент).
// Если пропустить конечный аргумент, возвратятся все элементы до конца массива.

my_array = [1, 3, 7];

// начиная с 3 индекса начинает вырезать, до 6 индеса, и вырезанный результат присвоить в новый массив
let sliced_array = my_array.slice(3, 6);
let copy_array = my_array.slice(0) // копия нашего массива

console.log(sliced_array); // [6, 88, 99]
console.log(copy_array); // [36, 43, 55, 6, 88, 99, 10, 12]

console.log(my_array); // [36, 43, 55,  6, 88, 99, 10, 12], при этом my_array неизменен

let last_two_el = my_array.slice(-2); // подсчет индекса сзади начинается с 1
let one_el_from_behind = my_array.slice(-2, -1);

console.log(last_two_el); // [4, 5], при этом my_array неизменен
console.log(one_el_from_behind); // [4], при этом my_array неизменен

console.log(my_array); // [36, 43, 55,  6, 88, 99, 10, 12], при этом my_array неизменен


/* №4 Добавление и удаление элементов в любой позиции */
//--------------------------------------------------------Splice--------------------------------------------------------
// Метод splice позволяет изменять массив по месту, добавляя и/или удаляя элементы из любого индекса.
// Первый аргумент - индекс, с которого должно начинаться изменение;
// Второй аргумент - количество удаляемых элементов (если вы не хотите удалять элементы, используйте О);
// Остальные аргументы - это добавляемые элементы;
my_array = [1, 5, 7];

// возвратит пустой [], если попытаемся присвоить переменне
my_array.splice(1, 0, 2, 3, 4); // изменяет исходный массив, теперь my_array [1, 2, 3, 4, 5, 7]
console.log(my_array); // [1, 2, 3, 4, 5, 7]

my_array.splice(5, 0, 6); // изменяет исходный массив, теперь my_array [1, 2, 3, 4, 5, 6, 7]
console.log(my_array); // [1, 2, 3, 4, 5, 6, 7]

my_array.splice(my_array.length - 1, 1, "end"); // изменяет исходный массив,
console.log(my_array); // [1, 2, 3, 4, 5, 6, "end"]

my_array.splice(my_array.length - 1, 1, ...[7, 8, 9, 10]); // изменяет исходный массив,
console.log(my_array); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]


/* №5 Копирование и вставка в пределах массива */
//------------------------------------------------------copyWithin------------------------------------------------------
// Cпецификация ЕSб представляет новый метод, copyWi thin, получающий последовательность элементов из массива,
// и копирующий по месту, в другую часть массива, переписывая любые находящиеся там элементы.
// Первый аргумент - куда вставить копированные элементы, второй аргумент - с какого индекса начинать копировать,
// а заключительный (необязательный) аргумент - где прекратить копирование.
// Как и в методе slice, вы можете использовать отрицательные числа для индексов начала и завершения;
my_array = [1, 5, 7, 9];

my_array.copyWithin(1, 2); // теперь my_array [1, 7, 9, 9]
console.log(my_array); // [1, 7, 9, 9]

my_array.copyWithin(2, 0, 2); // теперь my_array [1, 3, 1, 3]
console.log(my_array); // [1, 3, 1, 3]

my_array.copyWithin(0, -3, -1); // теперь my_array [3, 1, 1, 3]
console.log(my_array); // [3, 1, 1, 3]


/* №6 Заполнение массива заданным значением */
//---------------------------------------------------------fill---------------------------------------------------------
// Спецификация ЕSб вводит новый метод, fill, который позволяет задать любое количество элементов с
// фиксированным значением (по месту). Он особенно полезен, когда используется вместе
// с конструктором Array (который позволяет определить начальный размер массива).
const fill_arr = new Array(5).fill(1); // fill_arr инициализируется [1, 1, 1, 1, 1]

fill_arr.fill("a"); // теперь fill_arr [ 'a', 'a', 'a', 'a', 'a' ]
fill_arr.fill("b", 1); // теперь fill_arr [ 'a', 'b', 'b', 'b', 'b' ]
fill_arr.fill("c", 2, 4); // теперь fill_arr [ 'a', 'b', 'c', 'c', 'b' ]
fill_arr.fill(5.5, -4); // теперь fill_arr [ 'a', 5.5, 5.5, 5.5, 5.5 ]
fill_arr.fill(0, -3, -1); // теперь fill_arr [ 'a', 5.5, 0, 0, 5.5 ]


/* №7 Разворот и сортировка массива */
//----------------------------------------------------Reverse, sort-----------------------------------------------------
// Метод reverse прост, он изменяет порядок элементов массива на обратный (по месту).
my_array = [1, 2, 3, 4, 5, 6];
my_array.reverse(); // теперь my_array [6, 5, 4, 3, 2, 1]

// Метод sort сортирует массив (по месту).Метод sort позволяет также определить функцию сортировки (sort function),
// которая может оказаться весьма удобной. Например, для сортировки объектов нет однозначного способа.

my_array.sort();
console.log(my_array); // [ 1, 2, 3, 4, 5, 6 ]

let my_array_names = [{name: "Suzanne"}, {name: "Jim"}, {name: "Trevor"}, {name: "Amanda"}];

// сортировка в алфавитном порядке по свойству name
my_array_names.sort((a, b) => a.name > b.name ? 1 : -1);
console.log(my_array_names); // [{ name: 'Amanda' },{ name: 'Jim' },{ name: 'Suzanne' },{ name: 'Trevor' }]


/* №8 Поиск в массиве */
//---------------------------------------IndexOf, lastIndexOf, findIndex, find -----------------------------------------
// Если вы хотите найти что-то в массиве, у вас есть несколько возможностей. Начнем со скромного метода indexOf,
// который был доступен в JavaScript довольно давно. Метод indexOf просто возвращает индекс первого найденного
// элемента, строго равного искомому (есть соответствующий метод lastIndexOf, осуществляющий поиск в обратном
// направлении и возвращающий последний индекс, который соответствует искомому).
// Чтобы выполнять поиск только в части массива, можно определить необязательный индекс начала.
// Если indexOf (или last indexOf) возвращает -1, это означает, что соответствие не найдено.

my_array = [1, 5, "a", 0, true, 5, [1, 2], "9"];

console.log(my_array.indexOf(5)); // 1
console.log(my_array.lastIndexOf(5)); // 5
console.log(my_array.indexOf("a")); // 2
console.log(my_array.lastIndexOf("a")); // 2
console.log(my_array.indexOf(5, 4)); // начинай поиск 5 , с индекса 4
console.log(my_array.indexOf(true, 3)); // 4
console.log(my_array.lastIndexOf(true, 3)); // -1

// Эмуляция IndexOf
const numbs = [9, 4, 6, 88, 7, 10, 15];

function indexOfEmul(arr, value, from = 0) {
    for (let i = from; i < arr.length; i++) {
        if (arr[i] === value) {
            return i;
        }
    }
    return -1;
}

console.log(indexOfEmul(numbs, 10));


// Далее, метод findIndex подобен методу indexOf в том, что возвращает индекс (или -1 при отсутствии соответствия),
// но более гибко. Он позволяет задать функцию, которая определяет, является ли элемент соответствующим
// (findIndex не может начать работу с произвольного индекса и не имеет аналога lastIndexOf).
my_array = [22, 33, 44, 55, 66, 77];

const res_find_index = my_array.findIndex(item => item > 55);
console.log(res_find_index); // вернул нам индекс 4


// Методы find и findIndex применяются при поиске индекса элемента. Но что если индекс элемента не интересен,
// а нужен только сам элемент? Метод find похож на findIndex тем, что позволяет определять функцию для поиска,
// но возвращает сам элемент, а не индекс (или null, если элемент не был найден).
// find - возвращает нам элемент который мы ищем, который подходит под условие, либо же возвращает нам undefined если не нашел.
my_array = [{id: 5, name: "Judith"}, {id: 7, name: "Francis"}];

const res_find = my_array.find(o => o.id === 5);
const res_find_undefined = my_array.find(o => o.id === 12);

console.log(res_find); // { id: 5, name: 'Judith' }
console.log(res_find_undefined); // undefined

class Person {
    static nextId = 0;

    constructor(name) {
        this.name = name;
        this.id = Person.nextId++;
    };
}

const jamie = new Person("Jamie"),
    juliet = new Person("Juliet"),
    peter = new Person("Peter"),
    jay = new Person("Jay");
let arr = [jamie, juliet, peter, jay];

console.log(arr.find(p => p.id === juliet.id));


// Подобно тому, как нас не всегда заботит индекс элемента в пределах массива, сам элемент нас тоже не всегда
// интересует: иногда мы просто хотим знать, есть он или нет. Очевидно, мы можем использовать одну из приведенных
// выше функций и выяснить, возвращает ли она -1 или undefined, но в JavaScript есть для этого два метода: some
// и every.

// some - есть ли хотя бы один который подходит к условию, возвращает true либо false
let data = [
    {name: "Dog", age: 20},
    {name: "Cat", age: 12},
    {name: "Goat", age: 18},
    {name: "Pig", age: 22},
    {name: "Meal", age: 10},
];

const isSomeAdult = data.some(obj => obj.age > 20); // Есть ли хотя бы один, кому больше 20
console.log(isSomeAdult); // true


// Метод every возвращает true, если каждый элемент в массиве удовлетворяет критерию, и false
// в противном случае.
const isAllAdult = data.every(obj => obj.age > 18); // Всем ли больше 18
console.log(isAllAdult); // false


/* №9 Фундаментальные операции над массивом: map и filter */
//-----------------------------------------------------Map, Filter------------------------------------------------------
// Из всех операций над массивом map и filter вы найдете самыми полезными. Просто удивительно, чего можно достичь
// с помощью этих двух методов. Метод map преобразует элементы в массиве. Во что? Это вам решать.
// У вас есть объекты, которые содержат числа, а вам нужны именно сами числа? Легко! Ваш массив содержит функции,
// а нужны возвращаемые ими значения? Легко! Всякий раз, когда массив находится в одном формате,
// а необходим другой, используйте метод map.
// Методы map и filter возвращают копии и не изменяют исходный массив. Давайте рассмотрим несколько примеров
const cart = [
    {name: "Widget", price: 9.95},
    {name: "Gadget", price: 22.95},
];

const names = cart.map(obj => obj.name), // [ 'Widget', 'Gadget' ]
    prices = cart.map(obj => obj.price), // [ 9.95, 22.95 ]
    discountPrices = prices.map(price => price * 0.8), // [ 7.96, 18.36 ]
    lwNames = names.map(name => name.toLowerCase()); // [ 'widget', 'gadget' ]

my_array = [1, 2, 3, 4, 5];
my_array[my_array.length + 1] = 7;

const squareNumbs = my_array.map(item => item ** 2);
console.log(squareNumbs); // [ 1, 4, 9, 16, 25, <1 empty item>, 49 ]

// Рассмотрим пример, в котором имеются наши товары и соответствующие
// цены в двух отдельных массивах, а мы хотим объединить
const new_cart = names.map((name, i) => {
    return {
        name: name,
        price: prices[i]
    };
});
console.log(new_cart);

let users = [
    {
        name: "    Zeke   ",
        age: 21
    },
    {
        name: "    Eren    ",
        age: 24
    },
    {
        name: "Ender",
        age: 20
    }
];

const filteredUsers = users.map((obj) => {
    obj.name = obj.name.trim().toLocaleLowerCase();
    return obj;
});
console.log(filteredUsers);


const temp = [0, 4, 6, 8, -2, 44]
const F = temp.map(numb => { // F = C * 1,8 + 32
    return numb * 1.8 + 32;
});
console.log(F); // [ 32, 39.2, 42.8, 46.4, 28.4, 111.2 ]


let a = [33, 44, 55, 66];
const b = a.map((item, index, array) => {
    if (index == 3) {
        array[index + 1] = 77;
    }
    return item;
});
console.log(b); // [ 33, 44, 55, 66 ]
console.log(a); //[ 33, 44, 55, 66, 77 ]


// Метод filter, как и подразумевает его имя, предназначен для удаления всего нежелательного из массива.
// Как и map, после удаления элементов он возвращает новый массив. Какие элементы удаляются? Это снова полностью ваше дело.
// Если вы догадались, что для определения удаляемых элементов мы предоставляем функцию, то вы уловили суть.
// Давайте рассмотрим несколько примеров.

// В filter нельзя вернуть index, или какое то другое число, так как это вызывает ошибку.
// Вы всегда должны возвращать true либо false, потому что программа всегда возвращаемое значение интепритирует как true
// либо false. Нельзя как в map сделать return item * 2;
my_array = [3, 4, 5, 6, 88];
const numb_bigger_ten = my_array.filter(item => {
    if (item > 10) {
        return item * 2; // это вырожение интепритируется как true, поэтому такие действие с умножением не сработает.
    }
});
console.log(numb_bigger_ten); // [88]

const return_index = my_array.filter((item, index) => {
    if (item > 10) {
        return index; // возвращаем индекс
    }
});
console.log(return_index); // [88], вместо индекса мы получили item, потому что index интерпритируется как true либо false


my_array = [3, 4, 5, 6, 88, "oleg", "andrey", "dima"];
const only_strings = my_array.filter((item, index, arr) => {
    // верни нам все кроме чисел , isNaN - проверка, не число ли оно,
    // другими словами мы ищем всё кроме чисел(булевые значения , строки и т.д.)
    if ((isNaN(item))) {
        return true;
    }
}).sort((a, b) => a - b);
console.log(only_strings); // ['andrey', 'dima', 'oleg']


my_array = [3, 4, 5, 6, 88, "oleg", "andrey", "dima"];
const only_numbs = my_array.filter((item, i, arr) => {
    // (!)меняет true на false, соответсвенно, в самом начале мы искали всё кроме чисел,
    // теперь наоборот мы ищем только числа
    if (!(isNaN(item))) {
        return true;
    }
})
console.log(only_numbs); // [ 3, 4, 5, 6, 88 ]


my_array = [3, 4, 5, 6, 8, 10, 2, 9, 0];
const even_numbs = my_array.filter(item => {
    if (item % 2 === 0) {
        return true;
    }
}).sort((a, b) => a - b);
console.log(even_numbs); // [ 0, 2, 4, 6, 8, 10 ]


const debt = [
    {
        name: "Olzhas",
        debt: 0
    },
    {
        name: "Ender",
        debt: 1000
    },
    {
        name: "Zeke",
        debt: 50
    },
    {
        name: "Eren",
        debt: 0
    },
    {
        name: "Mikasa",
        debt: 12000
    },
]
const collector = debt.filter((obj) => obj.debt > 10)
    .sort((a, b) => a.debt - b.debt)
console.log(collector); // [{name: "Zeke", debt: 50},{name: "Ender", debt: 1000},{name: "Mikasa", debt: 12000},]

const copy_all_debt_users = debt.filter((obj) => {
    // пустая содержится в начале и конце любой строки, а так же между словами, поэтому тут возвращается true
    return obj.name.includes("");
});
console.log(copy_all_debt_users); // [{name: "Olzhas", debt: 0},{name: "Ender", debt: 1000},{name: "Zeke", debt: 50},{name: "Eren", debt: 0},{name: "Mikasa", debt: 12000},]


/* №10 Магия массивов: метод reduce */
//------------------------------------------------------Reduce----------------------------------------------------------
// Из всех методов массивов мой любимый - reduce. В то время как map преобразует каждый элемент в массиве,
// метод reduce преобразует весь массив. Он называется reduce потому, что зачастую используется для сведения
// (reduce) массива к единому  значению. Например, суммирование чисел, хранящихся в массиве, или вычисление
// их среднего являются способами свести массив к единому значению. Однако фактически результатом сведения к
// единому значению может быть объект или другой массив - метод reduce способен воспроизвести возможности
// функций map и filter (и если на то пошло, любой другой рассмотренной здесь функции массива).

// Метод reduce, подобно map и filter, позволяет предоставить функцию, которая контролирует результат.
// Прежде мы уже имели дело с функциями обратного вызова (callback), первый переданный им элемент всегда
// является текущим элементом массива. Однако первое значение функции reduce - аккумулятор (accumulator),
// в который сводится массив. Остальная часть аргументов вполне ожидаема: текущий элемент массива,
// текущий индекс и сам массив.

// Помимо функции обратного вызова, методу reduce передается (необязательно) начальное значение для аккумулятора.
// Давайте рассмотрим простой пример - суммирование чисел в масси

my_array = [5, 8, 2, 4];
const sum = my_array.reduce((a, x) => a = a + x, 0);
console.log(sum); // 19

// для корректной работы , всегда лучше возвращать accum , а перед ним делать какие то операции и присваивать в accum

my_array = [-22, 33, 55, -10, -20]; // подсчет только положительных чисел
let sum_positive_numbs = my_array.reduce((accum, item) => {
    if (item > 0) {
        accum = accum + item;
    }
    return accum;
}, 0);
console.log(sum_positive_numbs); // 88


/* №11 Методы массива и удалённые или еще не определенные элементы */
//---------------------------------------------------<empty item>-------------------------------------------------------
// Зачастую недопонимание поведения методов массива ведет к неправильным предположениям относительно обработки
// ими элементов, которые были удалены или еще не были определены. Методы map, filter и reduce не вызывают функцию
// для элементов, которые никогда не присваивались или были удалены. Например, до ЕSб, если бы вы попытались
// хитро инициализировать массив таким способом, то были бы разочарованы.
arr = new Array(10).map(el => 5);
console.log(arr); // [ <10 empty items> ]
// Массив arr был бы массивом с 10 элементами, но все они содержали бы значение undefined. Точно так же,
// если вы удалите элемент из середины массива, а затем вызовете метод map, то получите массив с "дыркой'.
arr = [1, 2, 3, 4, 5];
delete arr[2];

console.log(arr); // [ 1, 2, <1 empty item>, 4, 5 ]


/* №12 Соединение строк */
//----------------------------------------------------Split, Join-------------------------------------------------------
// Довольно часто приходится объединять (строковые) значения элементов массива, используя некий разделитель.
// Функция Array.prototype.join получает один аргумент, разделитель (стандартно - запятая, если вы его не укажете),
// и возвращает строку с объединенными элементами (включая еще не определенные и удаленные элементы в виде пустых строк;
// значения null и undefined также становятся пустыми строками).

arr = [1, null, "hello", "world"];
delete arr[2];
const arr_str_default = arr.join(),
    arr_str_quotation = arr.join(""),
    arr_str_hyphen = arr.join("--");

console.log(arr_str_default); // 1,,,world
console.log(arr_str_quotation); // 1world
console.log(arr_str_hyphen); // 1------world


// split - разбить строку, и превратить в массив
let str = "olzhas",
    clever_str = "olzhas clever"

const all_to_array = str.split(), // всю строку перегнал в массив
    quotation = str.split("", 3),  // каждую букву разделил "" , а также вторым аргументом указал, до какого элемента
    word_quotation = clever_str.split(' '); // передаем внутрь строку с пробелом

console.log(all_to_array); // [ 'olzhas' ]
console.log(quotation); // [ 'o', 'l', 'z' ]
console.log(word_quotation); // [ 'olzhas', 'clever' ]


// join - делает наоборот, превращает массив в строку
str = ["d", "a", "n", "i", "e", "l"]
const str_names = ["daniel", "olzhas"]

let empt = str_names.join() // если разделитель не указывать , то идет разделение через запятую
let kovich = str.join('') // если разделитель не указывать , то идет разделение через запятую
let defis = str.join('-') // если разделитель не указывать , то идет разделение через запятую

console.log(empt); // "daniel,olzhas"
console.log(kovich); // "daniel"
console.log(defis);// "d-a-n-i-e-l"


//-----------------------------------------------------Includes---------------------------------------------------------
// JavaScript метод includes()ECMAScript 2016 позволяет определить, содержит ли массив искомый элемент.
// В случае нахождения элемента метод возвращает логическое значение true, в обратном случае false.
// includes(вещь которую ищешь , позиция)

my_array = ["abc", "olzhas", "ABC", 77, 98];
console.log(my_array.includes(77, 2)) // true

if (my_array.includes(77, 2)) {
    console.log("Содержит.")
} else {
    console.log("Не содержит.")
}

str = "qwertyuio"
if (str.includes("qw")) {
    console.log("Содержит.")
} else {
    console.log("Не содержит.")
}

users = [
    {
        name: "Olzhas",
        age: 18
    },
    {
        name: "Ivan",
        age: 19
    },
    {
        name: "Ender",
        age: 20
    }
]

const current_user = users.filter((obj) => {
    return obj.name.includes("Ivan");
});
console.log(current_user); // true


//-----------------------------------------------------isArray----------------------------------------------------------
// isArray - проверка является ли он массивом , возвращает нам true либо false
console.log(Array.isArray(users)) // true


//-----------------------------------------------------Spread-----------------------------------------------------------
// Spread
// #1
my_array = ["ddd", 55, 66]
second_array = ["b", 155, 66]

let copy_two_array = [...my_array, ...second_array]
console.log(copy_two_array) // [ 'ddd', 55, 66, 'b', 155, 66 ]

// #2
const strArr = [...'hello']
console.log(strArr) // [ 'h', 'e', 'l', 'l', 'o' ]

// #3
const setArr = [...new Set([1, 1, 2, 3, 4, 4])];
console.log(setArr); // [ 1, 2, 3, 4 ]

// #4
//NodeList -> Array
/* let p = document.querySelectorAll("p");
console.log(p) // NodeList
console.log([...p]) // Array */


